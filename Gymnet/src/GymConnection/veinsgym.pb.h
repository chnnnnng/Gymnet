// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: veinsgym.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_veinsgym_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_veinsgym_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_veinsgym_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_veinsgym_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_veinsgym_2eproto;
namespace veinsgym {
namespace proto {
class Box;
struct BoxDefaultTypeInternal;
extern BoxDefaultTypeInternal _Box_default_instance_;
class Dict;
struct DictDefaultTypeInternal;
extern DictDefaultTypeInternal _Dict_default_instance_;
class Dict_Item;
struct Dict_ItemDefaultTypeInternal;
extern Dict_ItemDefaultTypeInternal _Dict_Item_default_instance_;
class Discrete;
struct DiscreteDefaultTypeInternal;
extern DiscreteDefaultTypeInternal _Discrete_default_instance_;
class Init;
struct InitDefaultTypeInternal;
extern InitDefaultTypeInternal _Init_default_instance_;
class MultiBinary;
struct MultiBinaryDefaultTypeInternal;
extern MultiBinaryDefaultTypeInternal _MultiBinary_default_instance_;
class MultiDiscrete;
struct MultiDiscreteDefaultTypeInternal;
extern MultiDiscreteDefaultTypeInternal _MultiDiscrete_default_instance_;
class Reply;
struct ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Shutdown;
struct ShutdownDefaultTypeInternal;
extern ShutdownDefaultTypeInternal _Shutdown_default_instance_;
class Space;
struct SpaceDefaultTypeInternal;
extern SpaceDefaultTypeInternal _Space_default_instance_;
class Step;
struct StepDefaultTypeInternal;
extern StepDefaultTypeInternal _Step_default_instance_;
class Tuple;
struct TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
}  // namespace proto
}  // namespace veinsgym
PROTOBUF_NAMESPACE_OPEN
template<> ::veinsgym::proto::Box* Arena::CreateMaybeMessage<::veinsgym::proto::Box>(Arena*);
template<> ::veinsgym::proto::Dict* Arena::CreateMaybeMessage<::veinsgym::proto::Dict>(Arena*);
template<> ::veinsgym::proto::Dict_Item* Arena::CreateMaybeMessage<::veinsgym::proto::Dict_Item>(Arena*);
template<> ::veinsgym::proto::Discrete* Arena::CreateMaybeMessage<::veinsgym::proto::Discrete>(Arena*);
template<> ::veinsgym::proto::Init* Arena::CreateMaybeMessage<::veinsgym::proto::Init>(Arena*);
template<> ::veinsgym::proto::MultiBinary* Arena::CreateMaybeMessage<::veinsgym::proto::MultiBinary>(Arena*);
template<> ::veinsgym::proto::MultiDiscrete* Arena::CreateMaybeMessage<::veinsgym::proto::MultiDiscrete>(Arena*);
template<> ::veinsgym::proto::Reply* Arena::CreateMaybeMessage<::veinsgym::proto::Reply>(Arena*);
template<> ::veinsgym::proto::Request* Arena::CreateMaybeMessage<::veinsgym::proto::Request>(Arena*);
template<> ::veinsgym::proto::Shutdown* Arena::CreateMaybeMessage<::veinsgym::proto::Shutdown>(Arena*);
template<> ::veinsgym::proto::Space* Arena::CreateMaybeMessage<::veinsgym::proto::Space>(Arena*);
template<> ::veinsgym::proto::Step* Arena::CreateMaybeMessage<::veinsgym::proto::Step>(Arena*);
template<> ::veinsgym::proto::Tuple* Arena::CreateMaybeMessage<::veinsgym::proto::Tuple>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace veinsgym {
namespace proto {

// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kInit = 2,
    kShutdown = 3,
    kStep = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kInitFieldNumber = 2,
    kShutdownFieldNumber = 3,
    kStepFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .veinsgym.proto.Init init = 2;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::veinsgym::proto::Init& init() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Init* release_init();
  ::veinsgym::proto::Init* mutable_init();
  void set_allocated_init(::veinsgym::proto::Init* init);
  private:
  const ::veinsgym::proto::Init& _internal_init() const;
  ::veinsgym::proto::Init* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::veinsgym::proto::Init* init);
  ::veinsgym::proto::Init* unsafe_arena_release_init();

  // .veinsgym.proto.Shutdown shutdown = 3;
  bool has_shutdown() const;
  private:
  bool _internal_has_shutdown() const;
  public:
  void clear_shutdown();
  const ::veinsgym::proto::Shutdown& shutdown() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Shutdown* release_shutdown();
  ::veinsgym::proto::Shutdown* mutable_shutdown();
  void set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown);
  private:
  const ::veinsgym::proto::Shutdown& _internal_shutdown() const;
  ::veinsgym::proto::Shutdown* _internal_mutable_shutdown();
  public:
  void unsafe_arena_set_allocated_shutdown(
      ::veinsgym::proto::Shutdown* shutdown);
  ::veinsgym::proto::Shutdown* unsafe_arena_release_shutdown();

  // .veinsgym.proto.Step step = 4;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  const ::veinsgym::proto::Step& step() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Step* release_step();
  ::veinsgym::proto::Step* mutable_step();
  void set_allocated_step(::veinsgym::proto::Step* step);
  private:
  const ::veinsgym::proto::Step& _internal_step() const;
  ::veinsgym::proto::Step* _internal_mutable_step();
  public:
  void unsafe_arena_set_allocated_step(
      ::veinsgym::proto::Step* step);
  ::veinsgym::proto::Step* unsafe_arena_release_step();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Request)
 private:
  class _Internal;
  void set_has_init();
  void set_has_shutdown();
  void set_has_step();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::veinsgym::proto::Init* init_;
    ::veinsgym::proto::Shutdown* shutdown_;
    ::veinsgym::proto::Step* step_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Reply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Reply) */ {
 public:
  inline Reply() : Reply(nullptr) {}
  ~Reply() override;
  explicit PROTOBUF_CONSTEXPR Reply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reply(const Reply& from);
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply& operator=(Reply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reply& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kInit = 2,
    kShutdown = 3,
    kAction = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Reply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Reply";
  }
  protected:
  explicit Reply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kInitFieldNumber = 2,
    kShutdownFieldNumber = 3,
    kActionFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .veinsgym.proto.Init init = 2;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::veinsgym::proto::Init& init() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Init* release_init();
  ::veinsgym::proto::Init* mutable_init();
  void set_allocated_init(::veinsgym::proto::Init* init);
  private:
  const ::veinsgym::proto::Init& _internal_init() const;
  ::veinsgym::proto::Init* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::veinsgym::proto::Init* init);
  ::veinsgym::proto::Init* unsafe_arena_release_init();

  // .veinsgym.proto.Shutdown shutdown = 3;
  bool has_shutdown() const;
  private:
  bool _internal_has_shutdown() const;
  public:
  void clear_shutdown();
  const ::veinsgym::proto::Shutdown& shutdown() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Shutdown* release_shutdown();
  ::veinsgym::proto::Shutdown* mutable_shutdown();
  void set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown);
  private:
  const ::veinsgym::proto::Shutdown& _internal_shutdown() const;
  ::veinsgym::proto::Shutdown* _internal_mutable_shutdown();
  public:
  void unsafe_arena_set_allocated_shutdown(
      ::veinsgym::proto::Shutdown* shutdown);
  ::veinsgym::proto::Shutdown* unsafe_arena_release_shutdown();

  // .veinsgym.proto.Space action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::veinsgym::proto::Space& action() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Space* release_action();
  ::veinsgym::proto::Space* mutable_action();
  void set_allocated_action(::veinsgym::proto::Space* action);
  private:
  const ::veinsgym::proto::Space& _internal_action() const;
  ::veinsgym::proto::Space* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::veinsgym::proto::Space* action);
  ::veinsgym::proto::Space* unsafe_arena_release_action();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Reply)
 private:
  class _Internal;
  void set_has_init();
  void set_has_shutdown();
  void set_has_action();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::veinsgym::proto::Init* init_;
    ::veinsgym::proto::Shutdown* shutdown_;
    ::veinsgym::proto::Space* action_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Init final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Init) */ {
 public:
  inline Init() : Init(nullptr) {}
  ~Init() override;
  explicit PROTOBUF_CONSTEXPR Init(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Init(const Init& from);
  Init(Init&& from) noexcept
    : Init() {
    *this = ::std::move(from);
  }

  inline Init& operator=(const Init& from) {
    CopyFrom(from);
    return *this;
  }
  inline Init& operator=(Init&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Init& default_instance() {
    return *internal_default_instance();
  }
  static inline const Init* internal_default_instance() {
    return reinterpret_cast<const Init*>(
               &_Init_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Init& a, Init& b) {
    a.Swap(&b);
  }
  inline void Swap(Init* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Init* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Init* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Init>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Init& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Init& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Init* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Init";
  }
  protected:
  explicit Init(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionSpaceCodeFieldNumber = 1,
    kObservationSpaceCodeFieldNumber = 2,
    kRewardSpaceCodeFieldNumber = 3,
  };
  // string action_space_code = 1;
  void clear_action_space_code();
  const std::string& action_space_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_space_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_space_code();
  PROTOBUF_NODISCARD std::string* release_action_space_code();
  void set_allocated_action_space_code(std::string* action_space_code);
  private:
  const std::string& _internal_action_space_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_space_code(const std::string& value);
  std::string* _internal_mutable_action_space_code();
  public:

  // string observation_space_code = 2;
  void clear_observation_space_code();
  const std::string& observation_space_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_observation_space_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_observation_space_code();
  PROTOBUF_NODISCARD std::string* release_observation_space_code();
  void set_allocated_observation_space_code(std::string* observation_space_code);
  private:
  const std::string& _internal_observation_space_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_observation_space_code(const std::string& value);
  std::string* _internal_mutable_observation_space_code();
  public:

  // string reward_space_code = 3;
  void clear_reward_space_code();
  const std::string& reward_space_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reward_space_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reward_space_code();
  PROTOBUF_NODISCARD std::string* release_reward_space_code();
  void set_allocated_reward_space_code(std::string* reward_space_code);
  private:
  const std::string& _internal_reward_space_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_space_code(const std::string& value);
  std::string* _internal_mutable_reward_space_code();
  public:

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Init)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_space_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr observation_space_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reward_space_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Shutdown final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:veinsgym.proto.Shutdown) */ {
 public:
  inline Shutdown() : Shutdown(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Shutdown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shutdown(const Shutdown& from);
  Shutdown(Shutdown&& from) noexcept
    : Shutdown() {
    *this = ::std::move(from);
  }

  inline Shutdown& operator=(const Shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shutdown& operator=(Shutdown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shutdown& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shutdown* internal_default_instance() {
    return reinterpret_cast<const Shutdown*>(
               &_Shutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Shutdown& a, Shutdown& b) {
    a.Swap(&b);
  }
  inline void Swap(Shutdown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shutdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shutdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shutdown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Shutdown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Shutdown& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Shutdown";
  }
  protected:
  explicit Shutdown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Shutdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Step final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Step) */ {
 public:
  inline Step() : Step(nullptr) {}
  ~Step() override;
  explicit PROTOBUF_CONSTEXPR Step(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Step(const Step& from);
  Step(Step&& from) noexcept
    : Step() {
    *this = ::std::move(from);
  }

  inline Step& operator=(const Step& from) {
    CopyFrom(from);
    return *this;
  }
  inline Step& operator=(Step&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Step& default_instance() {
    return *internal_default_instance();
  }
  static inline const Step* internal_default_instance() {
    return reinterpret_cast<const Step*>(
               &_Step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Step& a, Step& b) {
    a.Swap(&b);
  }
  inline void Swap(Step* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Step* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Step>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Step& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Step& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Step* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Step";
  }
  protected:
  explicit Step(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObservationFieldNumber = 1,
    kRewardFieldNumber = 2,
    kInfoFieldNumber = 3,
  };
  // .veinsgym.proto.Space observation = 1;
  bool has_observation() const;
  private:
  bool _internal_has_observation() const;
  public:
  void clear_observation();
  const ::veinsgym::proto::Space& observation() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Space* release_observation();
  ::veinsgym::proto::Space* mutable_observation();
  void set_allocated_observation(::veinsgym::proto::Space* observation);
  private:
  const ::veinsgym::proto::Space& _internal_observation() const;
  ::veinsgym::proto::Space* _internal_mutable_observation();
  public:
  void unsafe_arena_set_allocated_observation(
      ::veinsgym::proto::Space* observation);
  ::veinsgym::proto::Space* unsafe_arena_release_observation();

  // .veinsgym.proto.Space reward = 2;
  bool has_reward() const;
  private:
  bool _internal_has_reward() const;
  public:
  void clear_reward();
  const ::veinsgym::proto::Space& reward() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Space* release_reward();
  ::veinsgym::proto::Space* mutable_reward();
  void set_allocated_reward(::veinsgym::proto::Space* reward);
  private:
  const ::veinsgym::proto::Space& _internal_reward() const;
  ::veinsgym::proto::Space* _internal_mutable_reward();
  public:
  void unsafe_arena_set_allocated_reward(
      ::veinsgym::proto::Space* reward);
  ::veinsgym::proto::Space* unsafe_arena_release_reward();

  // .veinsgym.proto.Space info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::veinsgym::proto::Space& info() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Space* release_info();
  ::veinsgym::proto::Space* mutable_info();
  void set_allocated_info(::veinsgym::proto::Space* info);
  private:
  const ::veinsgym::proto::Space& _internal_info() const;
  ::veinsgym::proto::Space* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::veinsgym::proto::Space* info);
  ::veinsgym::proto::Space* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Step)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::veinsgym::proto::Space* observation_;
  ::veinsgym::proto::Space* reward_;
  ::veinsgym::proto::Space* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Space final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Space) */ {
 public:
  inline Space() : Space(nullptr) {}
  ~Space() override;
  explicit PROTOBUF_CONSTEXPR Space(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Space(const Space& from);
  Space(Space&& from) noexcept
    : Space() {
    *this = ::std::move(from);
  }

  inline Space& operator=(const Space& from) {
    CopyFrom(from);
    return *this;
  }
  inline Space& operator=(Space&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Space& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kBox = 1,
    kDict = 2,
    kDiscrete = 3,
    kMultiBinary = 4,
    kMultiDiscrete = 5,
    kTuple = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const Space* internal_default_instance() {
    return reinterpret_cast<const Space*>(
               &_Space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Space& a, Space& b) {
    a.Swap(&b);
  }
  inline void Swap(Space* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Space* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Space* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Space>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Space& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Space& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Space* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Space";
  }
  protected:
  explicit Space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
    kDictFieldNumber = 2,
    kDiscreteFieldNumber = 3,
    kMultiBinaryFieldNumber = 4,
    kMultiDiscreteFieldNumber = 5,
    kTupleFieldNumber = 6,
  };
  // .veinsgym.proto.Box box = 1;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::veinsgym::proto::Box& box() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Box* release_box();
  ::veinsgym::proto::Box* mutable_box();
  void set_allocated_box(::veinsgym::proto::Box* box);
  private:
  const ::veinsgym::proto::Box& _internal_box() const;
  ::veinsgym::proto::Box* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::veinsgym::proto::Box* box);
  ::veinsgym::proto::Box* unsafe_arena_release_box();

  // .veinsgym.proto.Dict dict = 2;
  bool has_dict() const;
  private:
  bool _internal_has_dict() const;
  public:
  void clear_dict();
  const ::veinsgym::proto::Dict& dict() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Dict* release_dict();
  ::veinsgym::proto::Dict* mutable_dict();
  void set_allocated_dict(::veinsgym::proto::Dict* dict);
  private:
  const ::veinsgym::proto::Dict& _internal_dict() const;
  ::veinsgym::proto::Dict* _internal_mutable_dict();
  public:
  void unsafe_arena_set_allocated_dict(
      ::veinsgym::proto::Dict* dict);
  ::veinsgym::proto::Dict* unsafe_arena_release_dict();

  // .veinsgym.proto.Discrete discrete = 3;
  bool has_discrete() const;
  private:
  bool _internal_has_discrete() const;
  public:
  void clear_discrete();
  const ::veinsgym::proto::Discrete& discrete() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Discrete* release_discrete();
  ::veinsgym::proto::Discrete* mutable_discrete();
  void set_allocated_discrete(::veinsgym::proto::Discrete* discrete);
  private:
  const ::veinsgym::proto::Discrete& _internal_discrete() const;
  ::veinsgym::proto::Discrete* _internal_mutable_discrete();
  public:
  void unsafe_arena_set_allocated_discrete(
      ::veinsgym::proto::Discrete* discrete);
  ::veinsgym::proto::Discrete* unsafe_arena_release_discrete();

  // .veinsgym.proto.MultiBinary multi_binary = 4;
  bool has_multi_binary() const;
  private:
  bool _internal_has_multi_binary() const;
  public:
  void clear_multi_binary();
  const ::veinsgym::proto::MultiBinary& multi_binary() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::MultiBinary* release_multi_binary();
  ::veinsgym::proto::MultiBinary* mutable_multi_binary();
  void set_allocated_multi_binary(::veinsgym::proto::MultiBinary* multi_binary);
  private:
  const ::veinsgym::proto::MultiBinary& _internal_multi_binary() const;
  ::veinsgym::proto::MultiBinary* _internal_mutable_multi_binary();
  public:
  void unsafe_arena_set_allocated_multi_binary(
      ::veinsgym::proto::MultiBinary* multi_binary);
  ::veinsgym::proto::MultiBinary* unsafe_arena_release_multi_binary();

  // .veinsgym.proto.MultiDiscrete multi_discrete = 5;
  bool has_multi_discrete() const;
  private:
  bool _internal_has_multi_discrete() const;
  public:
  void clear_multi_discrete();
  const ::veinsgym::proto::MultiDiscrete& multi_discrete() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::MultiDiscrete* release_multi_discrete();
  ::veinsgym::proto::MultiDiscrete* mutable_multi_discrete();
  void set_allocated_multi_discrete(::veinsgym::proto::MultiDiscrete* multi_discrete);
  private:
  const ::veinsgym::proto::MultiDiscrete& _internal_multi_discrete() const;
  ::veinsgym::proto::MultiDiscrete* _internal_mutable_multi_discrete();
  public:
  void unsafe_arena_set_allocated_multi_discrete(
      ::veinsgym::proto::MultiDiscrete* multi_discrete);
  ::veinsgym::proto::MultiDiscrete* unsafe_arena_release_multi_discrete();

  // .veinsgym.proto.Tuple tuple = 6;
  bool has_tuple() const;
  private:
  bool _internal_has_tuple() const;
  public:
  void clear_tuple();
  const ::veinsgym::proto::Tuple& tuple() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Tuple* release_tuple();
  ::veinsgym::proto::Tuple* mutable_tuple();
  void set_allocated_tuple(::veinsgym::proto::Tuple* tuple);
  private:
  const ::veinsgym::proto::Tuple& _internal_tuple() const;
  ::veinsgym::proto::Tuple* _internal_mutable_tuple();
  public:
  void unsafe_arena_set_allocated_tuple(
      ::veinsgym::proto::Tuple* tuple);
  ::veinsgym::proto::Tuple* unsafe_arena_release_tuple();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:veinsgym.proto.Space)
 private:
  class _Internal;
  void set_has_box();
  void set_has_dict();
  void set_has_discrete();
  void set_has_multi_binary();
  void set_has_multi_discrete();
  void set_has_tuple();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::veinsgym::proto::Box* box_;
    ::veinsgym::proto::Dict* dict_;
    ::veinsgym::proto::Discrete* discrete_;
    ::veinsgym::proto::MultiBinary* multi_binary_;
    ::veinsgym::proto::MultiDiscrete* multi_discrete_;
    ::veinsgym::proto::Tuple* tuple_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Box final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Box) */ {
 public:
  inline Box() : Box(nullptr) {}
  ~Box() override;
  explicit PROTOBUF_CONSTEXPR Box(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Box(const Box& from);
  Box(Box&& from) noexcept
    : Box() {
    *this = ::std::move(from);
  }

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }
  inline Box& operator=(Box&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Box& default_instance() {
    return *internal_default_instance();
  }
  static inline const Box* internal_default_instance() {
    return reinterpret_cast<const Box*>(
               &_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Box& a, Box& b) {
    a.Swap(&b);
  }
  inline void Swap(Box* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Box* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Box* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Box>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Box& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Box& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Box";
  }
  protected:
  explicit Box(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Box)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Dict_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Dict.Item) */ {
 public:
  inline Dict_Item() : Dict_Item(nullptr) {}
  ~Dict_Item() override;
  explicit PROTOBUF_CONSTEXPR Dict_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dict_Item(const Dict_Item& from);
  Dict_Item(Dict_Item&& from) noexcept
    : Dict_Item() {
    *this = ::std::move(from);
  }

  inline Dict_Item& operator=(const Dict_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dict_Item& operator=(Dict_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dict_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dict_Item* internal_default_instance() {
    return reinterpret_cast<const Dict_Item*>(
               &_Dict_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Dict_Item& a, Dict_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Dict_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dict_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dict_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dict_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dict_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Dict_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dict_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Dict.Item";
  }
  protected:
  explicit Dict_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .veinsgym.proto.Space value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::veinsgym::proto::Space& value() const;
  PROTOBUF_NODISCARD ::veinsgym::proto::Space* release_value();
  ::veinsgym::proto::Space* mutable_value();
  void set_allocated_value(::veinsgym::proto::Space* value);
  private:
  const ::veinsgym::proto::Space& _internal_value() const;
  ::veinsgym::proto::Space* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::veinsgym::proto::Space* value);
  ::veinsgym::proto::Space* unsafe_arena_release_value();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Dict.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::veinsgym::proto::Space* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Dict final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Dict) */ {
 public:
  inline Dict() : Dict(nullptr) {}
  ~Dict() override;
  explicit PROTOBUF_CONSTEXPR Dict(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dict(const Dict& from);
  Dict(Dict&& from) noexcept
    : Dict() {
    *this = ::std::move(from);
  }

  inline Dict& operator=(const Dict& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dict& operator=(Dict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dict& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dict* internal_default_instance() {
    return reinterpret_cast<const Dict*>(
               &_Dict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Dict& a, Dict& b) {
    a.Swap(&b);
  }
  inline void Swap(Dict* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dict* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dict* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dict>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dict& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Dict& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dict* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Dict";
  }
  protected:
  explicit Dict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Dict_Item Item;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .veinsgym.proto.Dict.Item values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::veinsgym::proto::Dict_Item* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Dict_Item >*
      mutable_values();
  private:
  const ::veinsgym::proto::Dict_Item& _internal_values(int index) const;
  ::veinsgym::proto::Dict_Item* _internal_add_values();
  public:
  const ::veinsgym::proto::Dict_Item& values(int index) const;
  ::veinsgym::proto::Dict_Item* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Dict_Item >&
      values() const;

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Dict)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Dict_Item > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Discrete final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Discrete) */ {
 public:
  inline Discrete() : Discrete(nullptr) {}
  ~Discrete() override;
  explicit PROTOBUF_CONSTEXPR Discrete(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Discrete(const Discrete& from);
  Discrete(Discrete&& from) noexcept
    : Discrete() {
    *this = ::std::move(from);
  }

  inline Discrete& operator=(const Discrete& from) {
    CopyFrom(from);
    return *this;
  }
  inline Discrete& operator=(Discrete&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Discrete& default_instance() {
    return *internal_default_instance();
  }
  static inline const Discrete* internal_default_instance() {
    return reinterpret_cast<const Discrete*>(
               &_Discrete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Discrete& a, Discrete& b) {
    a.Swap(&b);
  }
  inline void Swap(Discrete* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Discrete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Discrete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Discrete>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Discrete& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Discrete& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Discrete* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Discrete";
  }
  protected:
  explicit Discrete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Discrete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class MultiBinary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.MultiBinary) */ {
 public:
  inline MultiBinary() : MultiBinary(nullptr) {}
  ~MultiBinary() override;
  explicit PROTOBUF_CONSTEXPR MultiBinary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiBinary(const MultiBinary& from);
  MultiBinary(MultiBinary&& from) noexcept
    : MultiBinary() {
    *this = ::std::move(from);
  }

  inline MultiBinary& operator=(const MultiBinary& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiBinary& operator=(MultiBinary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiBinary& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiBinary* internal_default_instance() {
    return reinterpret_cast<const MultiBinary*>(
               &_MultiBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MultiBinary& a, MultiBinary& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiBinary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiBinary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiBinary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiBinary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiBinary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiBinary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiBinary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.MultiBinary";
  }
  protected:
  explicit MultiBinary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.MultiBinary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class MultiDiscrete final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.MultiDiscrete) */ {
 public:
  inline MultiDiscrete() : MultiDiscrete(nullptr) {}
  ~MultiDiscrete() override;
  explicit PROTOBUF_CONSTEXPR MultiDiscrete(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiDiscrete(const MultiDiscrete& from);
  MultiDiscrete(MultiDiscrete&& from) noexcept
    : MultiDiscrete() {
    *this = ::std::move(from);
  }

  inline MultiDiscrete& operator=(const MultiDiscrete& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiDiscrete& operator=(MultiDiscrete&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiDiscrete& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiDiscrete* internal_default_instance() {
    return reinterpret_cast<const MultiDiscrete*>(
               &_MultiDiscrete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MultiDiscrete& a, MultiDiscrete& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiDiscrete* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiDiscrete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiDiscrete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiDiscrete>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiDiscrete& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiDiscrete& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiDiscrete* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.MultiDiscrete";
  }
  protected:
  explicit MultiDiscrete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_values() const;
  void _internal_add_values(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_values();
  public:
  uint64_t values(int index) const;
  void set_values(int index, uint64_t value);
  void add_values(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:veinsgym.proto.MultiDiscrete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > values_;
  mutable std::atomic<int> _values_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// -------------------------------------------------------------------

class Tuple final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:veinsgym.proto.Tuple) */ {
 public:
  inline Tuple() : Tuple(nullptr) {}
  ~Tuple() override;
  explicit PROTOBUF_CONSTEXPR Tuple(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tuple(const Tuple& from);
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tuple& operator=(Tuple&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tuple& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Tuple* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tuple& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tuple& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "veinsgym.proto.Tuple";
  }
  protected:
  explicit Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .veinsgym.proto.Space values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::veinsgym::proto::Space* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Space >*
      mutable_values();
  private:
  const ::veinsgym::proto::Space& _internal_values(int index) const;
  ::veinsgym::proto::Space* _internal_add_values();
  public:
  const ::veinsgym::proto::Space& values(int index) const;
  ::veinsgym::proto::Space* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Space >&
      values() const;

  // @@protoc_insertion_point(class_scope:veinsgym.proto.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Space > values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_veinsgym_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// uint64 id = 1;
inline void Request::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Request::_internal_id() const {
  return id_;
}
inline uint64_t Request::id() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.id)
  return _internal_id();
}
inline void Request::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Request::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Request.id)
}

// .veinsgym.proto.Init init = 2;
inline bool Request::_internal_has_init() const {
  return payload_case() == kInit;
}
inline bool Request::has_init() const {
  return _internal_has_init();
}
inline void Request::set_has_init() {
  _oneof_case_[0] = kInit;
}
inline void Request::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.init_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Init* Request::release_init() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::veinsgym::proto::Init* temp = payload_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Init& Request::_internal_init() const {
  return _internal_has_init()
      ? *payload_.init_
      : reinterpret_cast< ::veinsgym::proto::Init&>(::veinsgym::proto::_Init_default_instance_);
}
inline const ::veinsgym::proto::Init& Request::init() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.init)
  return _internal_init();
}
inline ::veinsgym::proto::Init* Request::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Request.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::veinsgym::proto::Init* temp = payload_.init_;
    payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_init(::veinsgym::proto::Init* init) {
  clear_payload();
  if (init) {
    set_has_init();
    payload_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Request.init)
}
inline ::veinsgym::proto::Init* Request::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_payload();
    set_has_init();
    payload_.init_ = CreateMaybeMessage< ::veinsgym::proto::Init >(GetArenaForAllocation());
  }
  return payload_.init_;
}
inline ::veinsgym::proto::Init* Request::mutable_init() {
  ::veinsgym::proto::Init* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.init)
  return _msg;
}

// .veinsgym.proto.Shutdown shutdown = 3;
inline bool Request::_internal_has_shutdown() const {
  return payload_case() == kShutdown;
}
inline bool Request::has_shutdown() const {
  return _internal_has_shutdown();
}
inline void Request::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Request::clear_shutdown() {
  if (_internal_has_shutdown()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.shutdown_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Shutdown* Request::release_shutdown() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_payload();
    ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Shutdown& Request::_internal_shutdown() const {
  return _internal_has_shutdown()
      ? *payload_.shutdown_
      : reinterpret_cast< ::veinsgym::proto::Shutdown&>(::veinsgym::proto::_Shutdown_default_instance_);
}
inline const ::veinsgym::proto::Shutdown& Request::shutdown() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.shutdown)
  return _internal_shutdown();
}
inline ::veinsgym::proto::Shutdown* Request::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Request.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_payload();
    ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown) {
  clear_payload();
  if (shutdown) {
    set_has_shutdown();
    payload_.shutdown_ = shutdown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Request.shutdown)
}
inline ::veinsgym::proto::Shutdown* Request::_internal_mutable_shutdown() {
  if (!_internal_has_shutdown()) {
    clear_payload();
    set_has_shutdown();
    payload_.shutdown_ = CreateMaybeMessage< ::veinsgym::proto::Shutdown >(GetArenaForAllocation());
  }
  return payload_.shutdown_;
}
inline ::veinsgym::proto::Shutdown* Request::mutable_shutdown() {
  ::veinsgym::proto::Shutdown* _msg = _internal_mutable_shutdown();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.shutdown)
  return _msg;
}

// .veinsgym.proto.Step step = 4;
inline bool Request::_internal_has_step() const {
  return payload_case() == kStep;
}
inline bool Request::has_step() const {
  return _internal_has_step();
}
inline void Request::set_has_step() {
  _oneof_case_[0] = kStep;
}
inline void Request::clear_step() {
  if (_internal_has_step()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.step_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Step* Request::release_step() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Request.step)
  if (_internal_has_step()) {
    clear_has_payload();
    ::veinsgym::proto::Step* temp = payload_.step_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Step& Request::_internal_step() const {
  return _internal_has_step()
      ? *payload_.step_
      : reinterpret_cast< ::veinsgym::proto::Step&>(::veinsgym::proto::_Step_default_instance_);
}
inline const ::veinsgym::proto::Step& Request::step() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Request.step)
  return _internal_step();
}
inline ::veinsgym::proto::Step* Request::unsafe_arena_release_step() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Request.step)
  if (_internal_has_step()) {
    clear_has_payload();
    ::veinsgym::proto::Step* temp = payload_.step_;
    payload_.step_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_step(::veinsgym::proto::Step* step) {
  clear_payload();
  if (step) {
    set_has_step();
    payload_.step_ = step;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Request.step)
}
inline ::veinsgym::proto::Step* Request::_internal_mutable_step() {
  if (!_internal_has_step()) {
    clear_payload();
    set_has_step();
    payload_.step_ = CreateMaybeMessage< ::veinsgym::proto::Step >(GetArenaForAllocation());
  }
  return payload_.step_;
}
inline ::veinsgym::proto::Step* Request::mutable_step() {
  ::veinsgym::proto::Step* _msg = _internal_mutable_step();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Request.step)
  return _msg;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Reply

// uint64 id = 1;
inline void Reply::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Reply::_internal_id() const {
  return id_;
}
inline uint64_t Reply::id() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.id)
  return _internal_id();
}
inline void Reply::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Reply::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Reply.id)
}

// .veinsgym.proto.Init init = 2;
inline bool Reply::_internal_has_init() const {
  return payload_case() == kInit;
}
inline bool Reply::has_init() const {
  return _internal_has_init();
}
inline void Reply::set_has_init() {
  _oneof_case_[0] = kInit;
}
inline void Reply::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.init_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Init* Reply::release_init() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::veinsgym::proto::Init* temp = payload_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Init& Reply::_internal_init() const {
  return _internal_has_init()
      ? *payload_.init_
      : reinterpret_cast< ::veinsgym::proto::Init&>(::veinsgym::proto::_Init_default_instance_);
}
inline const ::veinsgym::proto::Init& Reply::init() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.init)
  return _internal_init();
}
inline ::veinsgym::proto::Init* Reply::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Reply.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::veinsgym::proto::Init* temp = payload_.init_;
    payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Reply::unsafe_arena_set_allocated_init(::veinsgym::proto::Init* init) {
  clear_payload();
  if (init) {
    set_has_init();
    payload_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Reply.init)
}
inline ::veinsgym::proto::Init* Reply::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_payload();
    set_has_init();
    payload_.init_ = CreateMaybeMessage< ::veinsgym::proto::Init >(GetArenaForAllocation());
  }
  return payload_.init_;
}
inline ::veinsgym::proto::Init* Reply::mutable_init() {
  ::veinsgym::proto::Init* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.init)
  return _msg;
}

// .veinsgym.proto.Shutdown shutdown = 3;
inline bool Reply::_internal_has_shutdown() const {
  return payload_case() == kShutdown;
}
inline bool Reply::has_shutdown() const {
  return _internal_has_shutdown();
}
inline void Reply::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Reply::clear_shutdown() {
  if (_internal_has_shutdown()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.shutdown_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Shutdown* Reply::release_shutdown() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_payload();
    ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Shutdown& Reply::_internal_shutdown() const {
  return _internal_has_shutdown()
      ? *payload_.shutdown_
      : reinterpret_cast< ::veinsgym::proto::Shutdown&>(::veinsgym::proto::_Shutdown_default_instance_);
}
inline const ::veinsgym::proto::Shutdown& Reply::shutdown() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.shutdown)
  return _internal_shutdown();
}
inline ::veinsgym::proto::Shutdown* Reply::unsafe_arena_release_shutdown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Reply.shutdown)
  if (_internal_has_shutdown()) {
    clear_has_payload();
    ::veinsgym::proto::Shutdown* temp = payload_.shutdown_;
    payload_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Reply::unsafe_arena_set_allocated_shutdown(::veinsgym::proto::Shutdown* shutdown) {
  clear_payload();
  if (shutdown) {
    set_has_shutdown();
    payload_.shutdown_ = shutdown;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Reply.shutdown)
}
inline ::veinsgym::proto::Shutdown* Reply::_internal_mutable_shutdown() {
  if (!_internal_has_shutdown()) {
    clear_payload();
    set_has_shutdown();
    payload_.shutdown_ = CreateMaybeMessage< ::veinsgym::proto::Shutdown >(GetArenaForAllocation());
  }
  return payload_.shutdown_;
}
inline ::veinsgym::proto::Shutdown* Reply::mutable_shutdown() {
  ::veinsgym::proto::Shutdown* _msg = _internal_mutable_shutdown();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.shutdown)
  return _msg;
}

// .veinsgym.proto.Space action = 4;
inline bool Reply::_internal_has_action() const {
  return payload_case() == kAction;
}
inline bool Reply::has_action() const {
  return _internal_has_action();
}
inline void Reply::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void Reply::clear_action() {
  if (_internal_has_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.action_;
    }
    clear_has_payload();
  }
}
inline ::veinsgym::proto::Space* Reply::release_action() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Reply.action)
  if (_internal_has_action()) {
    clear_has_payload();
    ::veinsgym::proto::Space* temp = payload_.action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Space& Reply::_internal_action() const {
  return _internal_has_action()
      ? *payload_.action_
      : reinterpret_cast< ::veinsgym::proto::Space&>(::veinsgym::proto::_Space_default_instance_);
}
inline const ::veinsgym::proto::Space& Reply::action() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Reply.action)
  return _internal_action();
}
inline ::veinsgym::proto::Space* Reply::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Reply.action)
  if (_internal_has_action()) {
    clear_has_payload();
    ::veinsgym::proto::Space* temp = payload_.action_;
    payload_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Reply::unsafe_arena_set_allocated_action(::veinsgym::proto::Space* action) {
  clear_payload();
  if (action) {
    set_has_action();
    payload_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Reply.action)
}
inline ::veinsgym::proto::Space* Reply::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_payload();
    set_has_action();
    payload_.action_ = CreateMaybeMessage< ::veinsgym::proto::Space >(GetArenaForAllocation());
  }
  return payload_.action_;
}
inline ::veinsgym::proto::Space* Reply::mutable_action() {
  ::veinsgym::proto::Space* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Reply.action)
  return _msg;
}

inline bool Reply::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Reply::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Reply::PayloadCase Reply::payload_case() const {
  return Reply::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Init

// string action_space_code = 1;
inline void Init::clear_action_space_code() {
  action_space_code_.ClearToEmpty();
}
inline const std::string& Init::action_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.action_space_code)
  return _internal_action_space_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_action_space_code(ArgT0&& arg0, ArgT... args) {
 
 action_space_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.action_space_code)
}
inline std::string* Init::mutable_action_space_code() {
  std::string* _s = _internal_mutable_action_space_code();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.action_space_code)
  return _s;
}
inline const std::string& Init::_internal_action_space_code() const {
  return action_space_code_.Get();
}
inline void Init::_internal_set_action_space_code(const std::string& value) {
  
  action_space_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_action_space_code() {
  
  return action_space_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_action_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.action_space_code)
  return action_space_code_.Release();
}
inline void Init::set_allocated_action_space_code(std::string* action_space_code) {
  if (action_space_code != nullptr) {
    
  } else {
    
  }
  action_space_code_.SetAllocated(action_space_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_space_code_.IsDefault()) {
    action_space_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.action_space_code)
}

// string observation_space_code = 2;
inline void Init::clear_observation_space_code() {
  observation_space_code_.ClearToEmpty();
}
inline const std::string& Init::observation_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.observation_space_code)
  return _internal_observation_space_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_observation_space_code(ArgT0&& arg0, ArgT... args) {
 
 observation_space_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.observation_space_code)
}
inline std::string* Init::mutable_observation_space_code() {
  std::string* _s = _internal_mutable_observation_space_code();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.observation_space_code)
  return _s;
}
inline const std::string& Init::_internal_observation_space_code() const {
  return observation_space_code_.Get();
}
inline void Init::_internal_set_observation_space_code(const std::string& value) {
  
  observation_space_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_observation_space_code() {
  
  return observation_space_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_observation_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.observation_space_code)
  return observation_space_code_.Release();
}
inline void Init::set_allocated_observation_space_code(std::string* observation_space_code) {
  if (observation_space_code != nullptr) {
    
  } else {
    
  }
  observation_space_code_.SetAllocated(observation_space_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (observation_space_code_.IsDefault()) {
    observation_space_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.observation_space_code)
}

// string reward_space_code = 3;
inline void Init::clear_reward_space_code() {
  reward_space_code_.ClearToEmpty();
}
inline const std::string& Init::reward_space_code() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Init.reward_space_code)
  return _internal_reward_space_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Init::set_reward_space_code(ArgT0&& arg0, ArgT... args) {
 
 reward_space_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:veinsgym.proto.Init.reward_space_code)
}
inline std::string* Init::mutable_reward_space_code() {
  std::string* _s = _internal_mutable_reward_space_code();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Init.reward_space_code)
  return _s;
}
inline const std::string& Init::_internal_reward_space_code() const {
  return reward_space_code_.Get();
}
inline void Init::_internal_set_reward_space_code(const std::string& value) {
  
  reward_space_code_.Set(value, GetArenaForAllocation());
}
inline std::string* Init::_internal_mutable_reward_space_code() {
  
  return reward_space_code_.Mutable(GetArenaForAllocation());
}
inline std::string* Init::release_reward_space_code() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Init.reward_space_code)
  return reward_space_code_.Release();
}
inline void Init::set_allocated_reward_space_code(std::string* reward_space_code) {
  if (reward_space_code != nullptr) {
    
  } else {
    
  }
  reward_space_code_.SetAllocated(reward_space_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reward_space_code_.IsDefault()) {
    reward_space_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Init.reward_space_code)
}

// -------------------------------------------------------------------

// Shutdown

// -------------------------------------------------------------------

// Step

// .veinsgym.proto.Space observation = 1;
inline bool Step::_internal_has_observation() const {
  return this != internal_default_instance() && observation_ != nullptr;
}
inline bool Step::has_observation() const {
  return _internal_has_observation();
}
inline void Step::clear_observation() {
  if (GetArenaForAllocation() == nullptr && observation_ != nullptr) {
    delete observation_;
  }
  observation_ = nullptr;
}
inline const ::veinsgym::proto::Space& Step::_internal_observation() const {
  const ::veinsgym::proto::Space* p = observation_;
  return p != nullptr ? *p : reinterpret_cast<const ::veinsgym::proto::Space&>(
      ::veinsgym::proto::_Space_default_instance_);
}
inline const ::veinsgym::proto::Space& Step::observation() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Step.observation)
  return _internal_observation();
}
inline void Step::unsafe_arena_set_allocated_observation(
    ::veinsgym::proto::Space* observation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(observation_);
  }
  observation_ = observation;
  if (observation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Step.observation)
}
inline ::veinsgym::proto::Space* Step::release_observation() {
  
  ::veinsgym::proto::Space* temp = observation_;
  observation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::veinsgym::proto::Space* Step::unsafe_arena_release_observation() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Step.observation)
  
  ::veinsgym::proto::Space* temp = observation_;
  observation_ = nullptr;
  return temp;
}
inline ::veinsgym::proto::Space* Step::_internal_mutable_observation() {
  
  if (observation_ == nullptr) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaForAllocation());
    observation_ = p;
  }
  return observation_;
}
inline ::veinsgym::proto::Space* Step::mutable_observation() {
  ::veinsgym::proto::Space* _msg = _internal_mutable_observation();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Step.observation)
  return _msg;
}
inline void Step::set_allocated_observation(::veinsgym::proto::Space* observation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete observation_;
  }
  if (observation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(observation);
    if (message_arena != submessage_arena) {
      observation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, observation, submessage_arena);
    }
    
  } else {
    
  }
  observation_ = observation;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Step.observation)
}

// .veinsgym.proto.Space reward = 2;
inline bool Step::_internal_has_reward() const {
  return this != internal_default_instance() && reward_ != nullptr;
}
inline bool Step::has_reward() const {
  return _internal_has_reward();
}
inline void Step::clear_reward() {
  if (GetArenaForAllocation() == nullptr && reward_ != nullptr) {
    delete reward_;
  }
  reward_ = nullptr;
}
inline const ::veinsgym::proto::Space& Step::_internal_reward() const {
  const ::veinsgym::proto::Space* p = reward_;
  return p != nullptr ? *p : reinterpret_cast<const ::veinsgym::proto::Space&>(
      ::veinsgym::proto::_Space_default_instance_);
}
inline const ::veinsgym::proto::Space& Step::reward() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Step.reward)
  return _internal_reward();
}
inline void Step::unsafe_arena_set_allocated_reward(
    ::veinsgym::proto::Space* reward) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reward_);
  }
  reward_ = reward;
  if (reward) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Step.reward)
}
inline ::veinsgym::proto::Space* Step::release_reward() {
  
  ::veinsgym::proto::Space* temp = reward_;
  reward_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::veinsgym::proto::Space* Step::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Step.reward)
  
  ::veinsgym::proto::Space* temp = reward_;
  reward_ = nullptr;
  return temp;
}
inline ::veinsgym::proto::Space* Step::_internal_mutable_reward() {
  
  if (reward_ == nullptr) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaForAllocation());
    reward_ = p;
  }
  return reward_;
}
inline ::veinsgym::proto::Space* Step::mutable_reward() {
  ::veinsgym::proto::Space* _msg = _internal_mutable_reward();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Step.reward)
  return _msg;
}
inline void Step::set_allocated_reward(::veinsgym::proto::Space* reward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reward_;
  }
  if (reward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reward);
    if (message_arena != submessage_arena) {
      reward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    
  } else {
    
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Step.reward)
}

// .veinsgym.proto.Space info = 3;
inline bool Step::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool Step::has_info() const {
  return _internal_has_info();
}
inline void Step::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::veinsgym::proto::Space& Step::_internal_info() const {
  const ::veinsgym::proto::Space* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::veinsgym::proto::Space&>(
      ::veinsgym::proto::_Space_default_instance_);
}
inline const ::veinsgym::proto::Space& Step::info() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Step.info)
  return _internal_info();
}
inline void Step::unsafe_arena_set_allocated_info(
    ::veinsgym::proto::Space* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Step.info)
}
inline ::veinsgym::proto::Space* Step::release_info() {
  
  ::veinsgym::proto::Space* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::veinsgym::proto::Space* Step::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Step.info)
  
  ::veinsgym::proto::Space* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::veinsgym::proto::Space* Step::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::veinsgym::proto::Space* Step::mutable_info() {
  ::veinsgym::proto::Space* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Step.info)
  return _msg;
}
inline void Step::set_allocated_info(::veinsgym::proto::Space* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Step.info)
}

// -------------------------------------------------------------------

// Space

// .veinsgym.proto.Box box = 1;
inline bool Space::_internal_has_box() const {
  return value_case() == kBox;
}
inline bool Space::has_box() const {
  return _internal_has_box();
}
inline void Space::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline void Space::clear_box() {
  if (_internal_has_box()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.box_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::Box* Space::release_box() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.box)
  if (_internal_has_box()) {
    clear_has_value();
    ::veinsgym::proto::Box* temp = value_.box_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Box& Space::_internal_box() const {
  return _internal_has_box()
      ? *value_.box_
      : reinterpret_cast< ::veinsgym::proto::Box&>(::veinsgym::proto::_Box_default_instance_);
}
inline const ::veinsgym::proto::Box& Space::box() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.box)
  return _internal_box();
}
inline ::veinsgym::proto::Box* Space::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.box)
  if (_internal_has_box()) {
    clear_has_value();
    ::veinsgym::proto::Box* temp = value_.box_;
    value_.box_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_box(::veinsgym::proto::Box* box) {
  clear_value();
  if (box) {
    set_has_box();
    value_.box_ = box;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.box)
}
inline ::veinsgym::proto::Box* Space::_internal_mutable_box() {
  if (!_internal_has_box()) {
    clear_value();
    set_has_box();
    value_.box_ = CreateMaybeMessage< ::veinsgym::proto::Box >(GetArenaForAllocation());
  }
  return value_.box_;
}
inline ::veinsgym::proto::Box* Space::mutable_box() {
  ::veinsgym::proto::Box* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.box)
  return _msg;
}

// .veinsgym.proto.Dict dict = 2;
inline bool Space::_internal_has_dict() const {
  return value_case() == kDict;
}
inline bool Space::has_dict() const {
  return _internal_has_dict();
}
inline void Space::set_has_dict() {
  _oneof_case_[0] = kDict;
}
inline void Space::clear_dict() {
  if (_internal_has_dict()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.dict_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::Dict* Space::release_dict() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.dict)
  if (_internal_has_dict()) {
    clear_has_value();
    ::veinsgym::proto::Dict* temp = value_.dict_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.dict_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Dict& Space::_internal_dict() const {
  return _internal_has_dict()
      ? *value_.dict_
      : reinterpret_cast< ::veinsgym::proto::Dict&>(::veinsgym::proto::_Dict_default_instance_);
}
inline const ::veinsgym::proto::Dict& Space::dict() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.dict)
  return _internal_dict();
}
inline ::veinsgym::proto::Dict* Space::unsafe_arena_release_dict() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.dict)
  if (_internal_has_dict()) {
    clear_has_value();
    ::veinsgym::proto::Dict* temp = value_.dict_;
    value_.dict_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_dict(::veinsgym::proto::Dict* dict) {
  clear_value();
  if (dict) {
    set_has_dict();
    value_.dict_ = dict;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.dict)
}
inline ::veinsgym::proto::Dict* Space::_internal_mutable_dict() {
  if (!_internal_has_dict()) {
    clear_value();
    set_has_dict();
    value_.dict_ = CreateMaybeMessage< ::veinsgym::proto::Dict >(GetArenaForAllocation());
  }
  return value_.dict_;
}
inline ::veinsgym::proto::Dict* Space::mutable_dict() {
  ::veinsgym::proto::Dict* _msg = _internal_mutable_dict();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.dict)
  return _msg;
}

// .veinsgym.proto.Discrete discrete = 3;
inline bool Space::_internal_has_discrete() const {
  return value_case() == kDiscrete;
}
inline bool Space::has_discrete() const {
  return _internal_has_discrete();
}
inline void Space::set_has_discrete() {
  _oneof_case_[0] = kDiscrete;
}
inline void Space::clear_discrete() {
  if (_internal_has_discrete()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.discrete_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::Discrete* Space::release_discrete() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.discrete)
  if (_internal_has_discrete()) {
    clear_has_value();
    ::veinsgym::proto::Discrete* temp = value_.discrete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Discrete& Space::_internal_discrete() const {
  return _internal_has_discrete()
      ? *value_.discrete_
      : reinterpret_cast< ::veinsgym::proto::Discrete&>(::veinsgym::proto::_Discrete_default_instance_);
}
inline const ::veinsgym::proto::Discrete& Space::discrete() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.discrete)
  return _internal_discrete();
}
inline ::veinsgym::proto::Discrete* Space::unsafe_arena_release_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.discrete)
  if (_internal_has_discrete()) {
    clear_has_value();
    ::veinsgym::proto::Discrete* temp = value_.discrete_;
    value_.discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_discrete(::veinsgym::proto::Discrete* discrete) {
  clear_value();
  if (discrete) {
    set_has_discrete();
    value_.discrete_ = discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.discrete)
}
inline ::veinsgym::proto::Discrete* Space::_internal_mutable_discrete() {
  if (!_internal_has_discrete()) {
    clear_value();
    set_has_discrete();
    value_.discrete_ = CreateMaybeMessage< ::veinsgym::proto::Discrete >(GetArenaForAllocation());
  }
  return value_.discrete_;
}
inline ::veinsgym::proto::Discrete* Space::mutable_discrete() {
  ::veinsgym::proto::Discrete* _msg = _internal_mutable_discrete();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.discrete)
  return _msg;
}

// .veinsgym.proto.MultiBinary multi_binary = 4;
inline bool Space::_internal_has_multi_binary() const {
  return value_case() == kMultiBinary;
}
inline bool Space::has_multi_binary() const {
  return _internal_has_multi_binary();
}
inline void Space::set_has_multi_binary() {
  _oneof_case_[0] = kMultiBinary;
}
inline void Space::clear_multi_binary() {
  if (_internal_has_multi_binary()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.multi_binary_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::MultiBinary* Space::release_multi_binary() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.multi_binary)
  if (_internal_has_multi_binary()) {
    clear_has_value();
    ::veinsgym::proto::MultiBinary* temp = value_.multi_binary_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.multi_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::MultiBinary& Space::_internal_multi_binary() const {
  return _internal_has_multi_binary()
      ? *value_.multi_binary_
      : reinterpret_cast< ::veinsgym::proto::MultiBinary&>(::veinsgym::proto::_MultiBinary_default_instance_);
}
inline const ::veinsgym::proto::MultiBinary& Space::multi_binary() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.multi_binary)
  return _internal_multi_binary();
}
inline ::veinsgym::proto::MultiBinary* Space::unsafe_arena_release_multi_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.multi_binary)
  if (_internal_has_multi_binary()) {
    clear_has_value();
    ::veinsgym::proto::MultiBinary* temp = value_.multi_binary_;
    value_.multi_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_multi_binary(::veinsgym::proto::MultiBinary* multi_binary) {
  clear_value();
  if (multi_binary) {
    set_has_multi_binary();
    value_.multi_binary_ = multi_binary;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.multi_binary)
}
inline ::veinsgym::proto::MultiBinary* Space::_internal_mutable_multi_binary() {
  if (!_internal_has_multi_binary()) {
    clear_value();
    set_has_multi_binary();
    value_.multi_binary_ = CreateMaybeMessage< ::veinsgym::proto::MultiBinary >(GetArenaForAllocation());
  }
  return value_.multi_binary_;
}
inline ::veinsgym::proto::MultiBinary* Space::mutable_multi_binary() {
  ::veinsgym::proto::MultiBinary* _msg = _internal_mutable_multi_binary();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.multi_binary)
  return _msg;
}

// .veinsgym.proto.MultiDiscrete multi_discrete = 5;
inline bool Space::_internal_has_multi_discrete() const {
  return value_case() == kMultiDiscrete;
}
inline bool Space::has_multi_discrete() const {
  return _internal_has_multi_discrete();
}
inline void Space::set_has_multi_discrete() {
  _oneof_case_[0] = kMultiDiscrete;
}
inline void Space::clear_multi_discrete() {
  if (_internal_has_multi_discrete()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.multi_discrete_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::MultiDiscrete* Space::release_multi_discrete() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.multi_discrete)
  if (_internal_has_multi_discrete()) {
    clear_has_value();
    ::veinsgym::proto::MultiDiscrete* temp = value_.multi_discrete_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.multi_discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::MultiDiscrete& Space::_internal_multi_discrete() const {
  return _internal_has_multi_discrete()
      ? *value_.multi_discrete_
      : reinterpret_cast< ::veinsgym::proto::MultiDiscrete&>(::veinsgym::proto::_MultiDiscrete_default_instance_);
}
inline const ::veinsgym::proto::MultiDiscrete& Space::multi_discrete() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.multi_discrete)
  return _internal_multi_discrete();
}
inline ::veinsgym::proto::MultiDiscrete* Space::unsafe_arena_release_multi_discrete() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.multi_discrete)
  if (_internal_has_multi_discrete()) {
    clear_has_value();
    ::veinsgym::proto::MultiDiscrete* temp = value_.multi_discrete_;
    value_.multi_discrete_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_multi_discrete(::veinsgym::proto::MultiDiscrete* multi_discrete) {
  clear_value();
  if (multi_discrete) {
    set_has_multi_discrete();
    value_.multi_discrete_ = multi_discrete;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.multi_discrete)
}
inline ::veinsgym::proto::MultiDiscrete* Space::_internal_mutable_multi_discrete() {
  if (!_internal_has_multi_discrete()) {
    clear_value();
    set_has_multi_discrete();
    value_.multi_discrete_ = CreateMaybeMessage< ::veinsgym::proto::MultiDiscrete >(GetArenaForAllocation());
  }
  return value_.multi_discrete_;
}
inline ::veinsgym::proto::MultiDiscrete* Space::mutable_multi_discrete() {
  ::veinsgym::proto::MultiDiscrete* _msg = _internal_mutable_multi_discrete();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.multi_discrete)
  return _msg;
}

// .veinsgym.proto.Tuple tuple = 6;
inline bool Space::_internal_has_tuple() const {
  return value_case() == kTuple;
}
inline bool Space::has_tuple() const {
  return _internal_has_tuple();
}
inline void Space::set_has_tuple() {
  _oneof_case_[0] = kTuple;
}
inline void Space::clear_tuple() {
  if (_internal_has_tuple()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.tuple_;
    }
    clear_has_value();
  }
}
inline ::veinsgym::proto::Tuple* Space::release_tuple() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Space.tuple)
  if (_internal_has_tuple()) {
    clear_has_value();
    ::veinsgym::proto::Tuple* temp = value_.tuple_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::veinsgym::proto::Tuple& Space::_internal_tuple() const {
  return _internal_has_tuple()
      ? *value_.tuple_
      : reinterpret_cast< ::veinsgym::proto::Tuple&>(::veinsgym::proto::_Tuple_default_instance_);
}
inline const ::veinsgym::proto::Tuple& Space::tuple() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Space.tuple)
  return _internal_tuple();
}
inline ::veinsgym::proto::Tuple* Space::unsafe_arena_release_tuple() {
  // @@protoc_insertion_point(field_unsafe_arena_release:veinsgym.proto.Space.tuple)
  if (_internal_has_tuple()) {
    clear_has_value();
    ::veinsgym::proto::Tuple* temp = value_.tuple_;
    value_.tuple_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Space::unsafe_arena_set_allocated_tuple(::veinsgym::proto::Tuple* tuple) {
  clear_value();
  if (tuple) {
    set_has_tuple();
    value_.tuple_ = tuple;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Space.tuple)
}
inline ::veinsgym::proto::Tuple* Space::_internal_mutable_tuple() {
  if (!_internal_has_tuple()) {
    clear_value();
    set_has_tuple();
    value_.tuple_ = CreateMaybeMessage< ::veinsgym::proto::Tuple >(GetArenaForAllocation());
  }
  return value_.tuple_;
}
inline ::veinsgym::proto::Tuple* Space::mutable_tuple() {
  ::veinsgym::proto::Tuple* _msg = _internal_mutable_tuple();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Space.tuple)
  return _msg;
}

inline bool Space::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Space::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Space::ValueCase Space::value_case() const {
  return Space::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Box

// repeated double values = 1;
inline int Box::_internal_values_size() const {
  return values_.size();
}
inline int Box::values_size() const {
  return _internal_values_size();
}
inline void Box::clear_values() {
  values_.Clear();
}
inline double Box::_internal_values(int index) const {
  return values_.Get(index);
}
inline double Box::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Box.values)
  return _internal_values(index);
}
inline void Box::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Box.values)
}
inline void Box::_internal_add_values(double value) {
  values_.Add(value);
}
inline void Box::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.Box.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Box::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Box::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Box.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Box::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Box::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Box.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Dict_Item

// string key = 1;
inline void Dict_Item::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Dict_Item::key() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.Item.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dict_Item::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:veinsgym.proto.Dict.Item.key)
}
inline std::string* Dict_Item::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.Item.key)
  return _s;
}
inline const std::string& Dict_Item::_internal_key() const {
  return key_.Get();
}
inline void Dict_Item::_internal_set_key(const std::string& value) {
  
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* Dict_Item::_internal_mutable_key() {
  
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* Dict_Item::release_key() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Dict.Item.key)
  return key_.Release();
}
inline void Dict_Item::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Dict.Item.key)
}

// .veinsgym.proto.Space value = 2;
inline bool Dict_Item::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool Dict_Item::has_value() const {
  return _internal_has_value();
}
inline void Dict_Item::clear_value() {
  if (GetArenaForAllocation() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::veinsgym::proto::Space& Dict_Item::_internal_value() const {
  const ::veinsgym::proto::Space* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::veinsgym::proto::Space&>(
      ::veinsgym::proto::_Space_default_instance_);
}
inline const ::veinsgym::proto::Space& Dict_Item::value() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.Item.value)
  return _internal_value();
}
inline void Dict_Item::unsafe_arena_set_allocated_value(
    ::veinsgym::proto::Space* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:veinsgym.proto.Dict.Item.value)
}
inline ::veinsgym::proto::Space* Dict_Item::release_value() {
  
  ::veinsgym::proto::Space* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::veinsgym::proto::Space* Dict_Item::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:veinsgym.proto.Dict.Item.value)
  
  ::veinsgym::proto::Space* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::veinsgym::proto::Space* Dict_Item::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::veinsgym::proto::Space>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::veinsgym::proto::Space* Dict_Item::mutable_value() {
  ::veinsgym::proto::Space* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.Item.value)
  return _msg;
}
inline void Dict_Item::set_allocated_value(::veinsgym::proto::Space* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:veinsgym.proto.Dict.Item.value)
}

// -------------------------------------------------------------------

// Dict

// repeated .veinsgym.proto.Dict.Item values = 1;
inline int Dict::_internal_values_size() const {
  return values_.size();
}
inline int Dict::values_size() const {
  return _internal_values_size();
}
inline void Dict::clear_values() {
  values_.Clear();
}
inline ::veinsgym::proto::Dict_Item* Dict::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Dict.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Dict_Item >*
Dict::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Dict.values)
  return &values_;
}
inline const ::veinsgym::proto::Dict_Item& Dict::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::veinsgym::proto::Dict_Item& Dict::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Dict.values)
  return _internal_values(index);
}
inline ::veinsgym::proto::Dict_Item* Dict::_internal_add_values() {
  return values_.Add();
}
inline ::veinsgym::proto::Dict_Item* Dict::add_values() {
  ::veinsgym::proto::Dict_Item* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:veinsgym.proto.Dict.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Dict_Item >&
Dict::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Dict.values)
  return values_;
}

// -------------------------------------------------------------------

// Discrete

// uint64 value = 1;
inline void Discrete::clear_value() {
  value_ = uint64_t{0u};
}
inline uint64_t Discrete::_internal_value() const {
  return value_;
}
inline uint64_t Discrete::value() const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Discrete.value)
  return _internal_value();
}
inline void Discrete::_internal_set_value(uint64_t value) {
  
  value_ = value;
}
inline void Discrete::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.Discrete.value)
}

// -------------------------------------------------------------------

// MultiBinary

// repeated bool values = 1;
inline int MultiBinary::_internal_values_size() const {
  return values_.size();
}
inline int MultiBinary::values_size() const {
  return _internal_values_size();
}
inline void MultiBinary::clear_values() {
  values_.Clear();
}
inline bool MultiBinary::_internal_values(int index) const {
  return values_.Get(index);
}
inline bool MultiBinary::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.MultiBinary.values)
  return _internal_values(index);
}
inline void MultiBinary::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.MultiBinary.values)
}
inline void MultiBinary::_internal_add_values(bool value) {
  values_.Add(value);
}
inline void MultiBinary::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.MultiBinary.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
MultiBinary::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
MultiBinary::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.MultiBinary.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
MultiBinary::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
MultiBinary::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.MultiBinary.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// MultiDiscrete

// repeated uint64 values = 1;
inline int MultiDiscrete::_internal_values_size() const {
  return values_.size();
}
inline int MultiDiscrete::values_size() const {
  return _internal_values_size();
}
inline void MultiDiscrete::clear_values() {
  values_.Clear();
}
inline uint64_t MultiDiscrete::_internal_values(int index) const {
  return values_.Get(index);
}
inline uint64_t MultiDiscrete::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.MultiDiscrete.values)
  return _internal_values(index);
}
inline void MultiDiscrete::set_values(int index, uint64_t value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:veinsgym.proto.MultiDiscrete.values)
}
inline void MultiDiscrete::_internal_add_values(uint64_t value) {
  values_.Add(value);
}
inline void MultiDiscrete::add_values(uint64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:veinsgym.proto.MultiDiscrete.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MultiDiscrete::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MultiDiscrete::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.MultiDiscrete.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MultiDiscrete::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MultiDiscrete::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.MultiDiscrete.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Tuple

// repeated .veinsgym.proto.Space values = 1;
inline int Tuple::_internal_values_size() const {
  return values_.size();
}
inline int Tuple::values_size() const {
  return _internal_values_size();
}
inline void Tuple::clear_values() {
  values_.Clear();
}
inline ::veinsgym::proto::Space* Tuple::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:veinsgym.proto.Tuple.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Space >*
Tuple::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:veinsgym.proto.Tuple.values)
  return &values_;
}
inline const ::veinsgym::proto::Space& Tuple::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::veinsgym::proto::Space& Tuple::values(int index) const {
  // @@protoc_insertion_point(field_get:veinsgym.proto.Tuple.values)
  return _internal_values(index);
}
inline ::veinsgym::proto::Space* Tuple::_internal_add_values() {
  return values_.Add();
}
inline ::veinsgym::proto::Space* Tuple::add_values() {
  ::veinsgym::proto::Space* _add = _internal_add_values();
  // @@protoc_insertion_point(field_add:veinsgym.proto.Tuple.values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::veinsgym::proto::Space >&
Tuple::values() const {
  // @@protoc_insertion_point(field_list:veinsgym.proto.Tuple.values)
  return values_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace veinsgym

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_veinsgym_2eproto
